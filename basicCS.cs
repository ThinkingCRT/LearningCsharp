namespace Basic.BasicCSProd 
{
    class BasicCS
    {
        
        public static void Column1(string[] args) 
        {
            //--------------------------------------------------------------------------------------------------------------------------------------//
            
            // переменные - контейнер для значений 

            // две разные переменные, т.к. C# регистрозависимый
            int num = 2;
            int Num = 3;
            Console.WriteLine(num); // 2
            Console.WriteLine(Num); // 3
            // переменную можно переопределить
            num = 6;
            Console.WriteLine(num); // 6, т.к таким образом, мы переопределили переменную

            //--------------------------------------------------------------------------------------------------------------------------------------//
            
            // константы

            const float numConst = 6;
            Console.WriteLine(numConst);
            // numConst = 4; - ошибка, константы нельзя переинициализировать

            //--------------------------------------------------------------------------------------------------------------------------------------//

            // типы данных

            int numInt = 26;                    // стандартный тип целочисленных данных - занимает 4 байта
            byte numByte = 45;                  // бинарный тип целочисленных данных - занимает 2 байта
            int sumByteInt = numInt + numByte;  // можно складывать байты и int т.к. байты весят меньше
            Console.WriteLine(sumByteInt);      // вывод и конвертиртация byte => int
            string sCTI = "123";
            int numConvert = int.Parse(sCTI);   // преобразование из строки в число
            int? nullTyp = null;                // int? пишется в том случае, что возможно пустое значение в переменной
            Console.WriteLine(nullTyp);         // пустота
            dynamic dynamicType = 6;            // int, определение переменной на этапе компиляции (не надо), не безопасный тип
            var unkownType = "unwn";            // всегда требует инициализации, использование там, где тип данных очевиден
            //var unkownType;                   // так делать нельзя
            Console.WriteLine(unkownType);      // ДЛЯ ИЗБЕЖАНИЯ ОШИБКИ ПРИ КОМПИЛЯЦИИ
            object objValue = "srt";            // object - родитель базовых классов, снижает производительность, исп. там, где тип неизвестен

            //--------------------------------------------------------------------------------------------------------------------------------------//

            // интерполяция

            int interpol1 = 69;
            int interpol2 = 53;
            Console.WriteLine($"Значение 1: {interpol1}, значение 2: {interpol2}");     // юзабельный способ интерполяции
            Console.WriteLine($"Результат интерполяции {interpol1 + interpol2}");       // выражение в интерполяции
            Console.WriteLine("Ещё можно так её оформить: " + interpol1);               // ещё один способ исполнения

            //--------------------------------------------------------------------------------------------------------------------------------------//
        }

        public static void Column2() 
        {
            //--------------------------------------------------------------------------------------------------------------------------------------//

            // Операнды - теория в диаграмме

            int numb11 = 64;
            int numb12 = 34;
            int plus = numb11 + numb12;                                  // бинарная арифметическая операция
            int ternar = numb11 > numb12 ? numb11 * numb12 : numb12 = 4; // тернарная операция
            numb11 += numb12;                                            // операция присвоения к numb11 - 98
            

            //--------------------------------------------------------------------------------------------------------------------------------------//
        }

        public static void Column3() 
        {
            //--------------------------------------------------------------------------------------------------------------------------------------//

            // Условные конструкции

            /******************************************************************* 
            if, else if, else - есть ещё switch/case ниже - алтернатива

            if, else if, else:
            для сложных условий - диапозоны, комбинированные проверки
            условия от 3-5
            для сложной логики
            любые логические выражения


            ******************************************************************/

            bool accessLuck = true;
            string isAdmin = "Admin";

            // два условия с логическим оператором "И" (для простой логики, сложнее отладка, производительность выше, чем у влож.if)
            if (accessLuck == true && isAdmin == "Admin")
            {
                Console.WriteLine("Разрешён полный доступ!");
            }
            // одно условие совпало
            else if (accessLuck == true)
            {
                Console.WriteLine("Разрешён доступ для чтения!");
            }
            // если два условия не совпадают, то отрабатывает этот код
            // по сути, ecли конструкция с одной строкой, то можно убрать скобки, if>1=>ошибка
            else
                Console.WriteLine("Доступе запрещён!"); 

            // альтернатива конструкции выше (для сложной логики, легче отладка, производительность меньше)
            if (accessLuck == true)                             
            {
                if (isAdmin == "Admin")
                {
                    Console.WriteLine("Разрешён полный доступ!");
                }
            }
            else if (accessLuck == true)
            {
                Console.WriteLine("Разрешён доступ для чтения!");
            }
            
            /*******************************************************************
            switch/case:
            проверка одной переменной на мн.значений
            условия 5+
            работа с перечислениями enum
            Pattern Maching C#7+
            поддержка сложных условий when
            switch expression C#8+
            в case можно использовать return - case значение: return;
            *******************************************************************/

            // Стандартный switch

            string days = "Night";
            string? dbAD = null;

            switch (days) 
            {
                case "Moning":
                    dbAD = "Moning";
                    break;
                case "Aftenoon":
                    dbAD = "Aftenoon";
                    break;
                case "Evening":
                    dbAD = "Evening";
                    break;
                case "Night":
                    dbAD = "Night";        // игнорит эту операцию
                    goto case "Midnight";  // переходи в midnight
                case "Midnight":
                    dbAD = "Midnight";     // получает значение от сюда
                    break;
                default:                   // аналог - else
                    Console.WriteLine("Это НЕ время дня!");
                    break;
            }
            Console.WriteLine($"Добавление данных в db: {dbAD}");

            // switch expression C#8+

            int? operation = 2;
            int vol1 = 61;
            int vol2 = 32;

            int result = operation switch
            {
                1 => vol1 + vol2,
                2 => vol1 - vol2,
                _ => 0
            };
            Console.WriteLine(result);
            
            //--------------------------------------------------------------------------------------------------------------------------------------//

            // Циклы

            /*******************************************************************
            For, Foreach, While, Do While

            for → Когда нужен индекс или точно известно число итераций.

            while → Когда условие выхода неизвестно заранее (например, ожидание события).

            foreach → Для простого перебора коллекций без управления индексом.
            ********************************************************************/

            int x = 10;
            for (; x>0; x--)
            {
                Console.WriteLine($"Значение x = {x}"); //1
            }


            int y = 10;
            do
            {
                Console.WriteLine($"Значение i = {y}"); //1
                y--;
            }
            while (y>0); 


            int z = 10;
            while(z>0)
            {
                Console.WriteLine($"Значение y = {z}"); //1
                z--;
            }

            // циклы в цикле

            // всего выполняется 9 итераций
            for (int i = 1; i < 10; i++)
            {
                // в рамках каждой итерации массив(родитель) выполняет одну, а дочерний 9         
                for (int j = 1; j < 10; j++)
                {
                    Console.Write($"{i * j} \t");
                }
                // каждая последующая итерация, после 9-ти дочерних, переносит на новую строку
                Console.WriteLine();              
            }

            // continue, break

            for(int br = 10; br>0; br--)
            {
                // четные числа не удовлетворяют условия и цикл продолжается
                if(br % 2 == 0) continue;
                // как только итерация доходит до 3-ки, цикл останавливается и 3-ку не выводит
                if(br == 3) break;
                Console.WriteLine($"Переменная br = {br}");
            }
            //--------------------------------------------------------------------------------------------------------------------------------------//
            
            // Массивы

            /******************************************************************* 
            
            Способы написание массивов

            // Одномерные массивы

            // Самый лаконичный, но нельзя использовать в методах, где тип не ясен
            int[] numbers = { 1, 2, 3, 4, 5 };
            // Тип выводится автоматически (int[]), можно использовать, где тип не ясен
            var numbers = new[] { 1, 2, 3 };
            // Избыточный, в старых версиях C#
            int[] numbers = new int[5] { 1, 2, 3, 4, 5 };
            // Самый удобный с C#12+, так же и в коллекциях
            int[] numbers = [ 1, 2, 3, 4, 5 ];
            // Самый оптимальный метод для написания пустого массива
            int[] empty1 = Array.Empty<int>(); // Оптимально (переиспользует память)

            // Многомерные массивы

            int[строка,столбец] dvm = new int[2,3] 	// [,] - два измерения массива (ранг, rank)
                                                    // длина измерений (2,3 dimension length)   								
                                                    // длина массива (5 array length)

            {1,2,3}, 	// (row, x, длинна)Строка 0, (column, y, высота)Столбец 0,1,2
            {4,5,6} 	// (row, x, длинна)Строка 1, (column, y, высота)Столбец 0,1,2
            
            
            св-ва:  array.GetLength(0) - число строк, 
            	    array.GetLength(1) - число столбцов
            	    array.Length	   - число эллементов в массиве
            	    array.Rank         - число измерений

            // Массивы в массиве

            int[][] ZB = {
                new int[] { 1, 2 }, 
                new int[] { 1, 2, 3 }, 
                new int[] { 1, 2, 3, 4, 5 } 
            };

            ********************************************************************/

            // Перебор массивов с помощью циклов

            // Одномерный массив

            int[] nump = [4, 4, 5, 7, 8, 10, 23, 435];  // обозначение одномерного массива
            
            // для чтения
            foreach (int i in nump) 
            {                   // из массива nump всё помещается в i
                Console.Write(" " + i + " ");           // все данные в i
                //Console.WriteLine(nump);              // массив пустой
            }

            // для перебора с изменениями
            // переменная i пустая, идёт просчитывание эллементов в массиве и помещается в i
            for (int i = 0; i < nump.Length; i++) 
            {
                nump[i] = nump[i] * 2;                  // можно изменять значения в массиве
                Console.Write(" " + nump[i] + " ");     // аналогично foreach
                //Console.Write(nump);                  // аналогично foreach
            }

            int i1 = 0;
            // идёт просчитывание эллементов в массиве и помещается в i1
            while (i1 < nump.Length) 
            {
                Console.Write(" " + nump[i1] + " ");    // аналогично foreach
                //Console.Write(nump);                  // аналогично foreach
                i1++;
            }
            Console.WriteLine("");  // для переноса строрки

            //--------------------------------------------------------------------------------------------------------------------------------------//

            // Многомерные массивы

            int[,] matrix = {
                {1,2,3},
                {4,5,6}
            };

            int columnY = matrix.GetLength(0);                 // индексы колон массива передаются в Y
            int rowX = matrix.GetLength(1);                    // индексы строк массива передаются в X

            // для перебора с изменениями
            for (int i = 0; i < columnY; i++) {                // в i помещаются индексы колонок
                for (int j = 0; j < rowX; j++) {               // в j помещаются индексы строк
                    Console.Write(matrix[i,j] + "\t" );        // итерация->инициализирует ячейку по индексам->значение->tab
                } 
                Console.WriteLine();
            }
            
            //--------------------------------------------------------------------------------------------------------------------------------------//

            // Массивы в массиве

            int[][] ZB = {
                new int[] { 1, 2 }, 
                new int[] { 1, 2, 3 }, 
                new int[] { 1, 2, 3, 4, 5 } 
            };
           
           // для перебора с изменениями
            for (int i = 0; i < ZB.Length; i++){          // в переменную i помещает индексы колонок, проводится 3 итерации 1-2, 1-3, 1-5
                for(int j = 0; j < ZB[i].Length; j++){    // в переменную j помещает индексы строк, проводит 10 итераций 1-2, 1-3, 1-5
                    Console.Write(ZB[i][j] + "\t");       // итерация->инициализирует ячейку по индексам->значение->tab
                }
                Console.WriteLine();                        // Отсупаем строку
            }
            
            // для чтения
            foreach(int[] row in ZB){               // из ZB - перемещает колонки, т.к. берёт int[]
                foreach(int index in row){          // по какой-то причине от сюда берёт строки
                    Console.Write($"{index} \t");
                }
                Console.WriteLine();
            }

            //--------------------------------------------------------------------------------------------------------------------------------------//
        }
    }

    class BasicCSMethod 
    {

        // написание метода - модификатор + тип, который вернёт + название + (параметры)
        // void не возвращает значение - он выполняет действие
        public void cosolWrite () 
        {    
            Console.Write("Структура метода");
        }
        public void consoleWriteDeclarative() => Console.WriteLine("Компактное написание");
        // параметры, которые содержаться в методе => формальные параметры
        // значение, которое передаётся в параметр при вызове функции из переменной => 
        // фактический параметр (аргумент)
        // string href = "Аргумент для метода";
        // параметры имеющие значения по умолчанию - пишуться в конце => необязательные параметры
        // но при этом выдаётся ошибка warning
        public static void DescriptionParams(string params1, ref string paramsH) //, string params2 = "p2")
        {;
            Console.WriteLine(params1);
            Console.WriteLine(paramsH + "\n");
        }
        // использование модификатора out - выходные данные, которые нужно помещать в переменные
        public static void OutModifi(int value1, int value2, out int value11, out int value22)
        {
            // инициализаци out переменных для преобразование выходных данных
            value11 = value1 * 2;  // Пример преобразования
            value22 = value2 + 10; // Пример преобразования

            Console.WriteLine($"Входные значения: {value1}, {value2}");
            Console.WriteLine($"Выходные значения: {value11}, {value22}");
        }
        // оператор return в методах
        public static int TransformationNum(int num1, int num2, out int result)
        {
            // возращает сумму двух переменных
            return result = num1 + num2;
        }
        // возращает сумму двух переменных, через лямбду выражение
        public static int TransformationNumLambda(int num1, int num2) => num1 + num2;
        // использование return в void методах
        public static void CheckAgeUsers(string name, int age)
        {
            if (age < 18 || age > 45)
            {
                Console.WriteLine("Возвраст не подходит!");
                return; // выход из функции
            } 
            else
            {
                Console.WriteLine($"Name: {name}, Age: {age}");
            }
        }

        // рекурсии
        // факториал числа - 
        public static int Factorial(int n)
        {
            // начало последовательности у факториалов начинается с еденицы
            // пока не будет единицы, функция будет вызываться
            if (n == 1) return 1;
            // суммирует и возвращает все значения, пока не будет выполнено условие
            return n * Factorial(n - 1);
            // например вводим 5-ку отладка будет такая:
            // 5*4 =! 1, 5*3 != 1, 5*2 =! 1, 5*1 != 1, 5*0 = 1, возвращает сумму всех значений
        }

        public static int Fibonachi(int n)
        {
            // начало последовательности в числах Ф. начинается с нуля и еденицы
            // пока не будет нуля или единицы, функция будет вызываться
            if (n == 0 || n == 1) return n;

            return Fibonachi(n - 1) + Fibonachi(n - 2);
        }

        // локальные функции

        public static void CompareArray(int[] numbers1, int[] numbers2)
        {
            int numbers1Sum = Sum(numbers1);    // первый результат лок.функции
            int numbers2Sum = Sum(numbers2);    // второй результат лок.функции

            if (numbers1Sum > numbers2Sum)
                Console.WriteLine("сумма чисел из массива numbers1 больше");
            else if (numbers1Sum < numbers2Sum)
                Console.WriteLine("сумма чисел из массива numbers2 больше");
            else
                Console.WriteLine("суммы чисел обоих массивов равны");
            
            // дабы не дублировать цикл, мы его используем один для двух операций
            int Sum(int[] numbers)	
            {
                int result = 0;
                // за каждую иттерацию, result суммирует числа с массива
                foreach (int number in numbers)
                    result += number; 
                // после завершения работы цикла, вернёт результат суммы чисел
                return result;
            }
        }
    }
    //--------------------------------------------Конец-------------------------------------------------------------------------------------//
}